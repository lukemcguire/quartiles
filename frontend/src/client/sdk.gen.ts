// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { GameStartGameData, GameStartGameResponse, GameValidateWordData, GameValidateWordResponse, GameSubmitGameData, GameSubmitGameResponse, GameGetHintData, GameGetHintResponse, LeaderboardGetTodaysLeaderboardData, LeaderboardGetTodaysLeaderboardResponse, LeaderboardGetLeaderboardByDateData, LeaderboardGetLeaderboardByDateResponse, LoginLoginAccessTokenData, LoginLoginAccessTokenResponse, LoginTestTokenResponse, LoginRecoverPasswordData, LoginRecoverPasswordResponse, LoginResetPasswordData, LoginResetPasswordResponse, LoginRecoverPasswordHtmlContentData, LoginRecoverPasswordHtmlContentResponse, PrivateCreateUserData, PrivateCreateUserResponse, PuzzleGetTodaysPuzzleResponse, PuzzleGetPuzzleByDateData, PuzzleGetPuzzleByDateResponse, UsersReadUsersData, UsersReadUsersResponse, UsersCreateUserData, UsersCreateUserResponse, UsersReadUserMeResponse, UsersDeleteUserMeResponse, UsersUpdateUserMeData, UsersUpdateUserMeResponse, UsersUpdatePasswordMeData, UsersUpdatePasswordMeResponse, UsersRegisterUserData, UsersRegisterUserResponse, UsersReadUserByIdData, UsersReadUserByIdResponse, UsersUpdateUserData, UsersUpdateUserResponse, UsersDeleteUserData, UsersDeleteUserResponse, UtilsTestEmailData, UtilsTestEmailResponse, UtilsHealthCheckResponse } from './types.gen';

export class GameService {
    /**
     * Start Game
     * Start a new game session.
     *
     * - Gets today's puzzle (creates if doesn't exist)
     * - Gets or creates player based on device_fingerprint/player_id
     * - Checks if player already completed today's puzzle
     * - Creates game session in database with server-recorded start_time
     * - Returns puzzle tiles only (NOT valid words - security)
     *
     * Returns:
     * GameStartResponse: Session info, player data, and puzzle tiles.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns GameStartResponse Successful Response
     * @throws ApiError
     */
    public static startGame(data: GameStartGameData): CancelablePromise<GameStartGameResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/game/start',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Validate Word
     * Validate a submitted word.
     *
     * Server-authoritative validation:
     * - Checks if word exists in puzzle's valid word set
     * - Checks if word was already found
     * - Returns points if valid, error reason if not
     * - Records valid word in session
     * - Checks if solve threshold reached
     *
     * Does NOT expose the valid word list to the client.
     *
     * Returns:
     * WordValidationResponse: Validation result with points and score.
     *
     * Raises:
     * HTTPException: If session not found, already completed, or puzzle not found.
     * @param data The data for the request.
     * @param data.sessionId
     * @param data.requestBody
     * @returns WordValidationResponse Successful Response
     * @throws ApiError
     */
    public static validateWord(data: GameValidateWordData): CancelablePromise<GameValidateWordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/game/sessions/{session_id}/word',
            path: {
                session_id: data.sessionId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Submit Game
     * Finalize and submit game for leaderboard.
     *
     * Server-authoritative scoring:
     * - Calculates final solve time: now() - start_time + hint_penalties
     * - Updates leaderboard if solved (score >= 100)
     * - Enforces first-play-wins (cannot resubmit)
     * - Client does NOT submit score or time
     *
     * Returns:
     * GameSubmitResponse: Final score, solve time, and leaderboard rank.
     *
     * Raises:
     * HTTPException: If session not found.
     * @param data The data for the request.
     * @param data.sessionId
     * @returns GameSubmitResponse Successful Response
     * @throws ApiError
     */
    public static submitGame(data: GameSubmitGameData): CancelablePromise<GameSubmitGameResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/game/sessions/{session_id}/submit',
            path: {
                session_id: data.sessionId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get Hint
     * Request a hint (definition of unfound quartile word).
     *
     * - Returns WordNet definition of one unfound quartile word
     * - Increments hint count in session
     * - Adds time penalty (30s, 60s, 120s, 240s, 480s)
     * - Maximum 5 hints per game
     *
     * Returns:
     * HintResponse: Hint number, definition, time penalty, and remaining quartiles.
     *
     * Raises:
     * HTTPException: If session not found, already completed, or max hints reached.
     * @param data The data for the request.
     * @param data.sessionId
     * @returns HintResponse Successful Response
     * @throws ApiError
     */
    public static getHint(data: GameGetHintData): CancelablePromise<GameGetHintResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/game/sessions/{session_id}/hint',
            path: {
                session_id: data.sessionId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class LeaderboardService {
    /**
     * Get Todays Leaderboard
     * Get today's leaderboard rankings.
     *
     * - Returns top `limit` entries sorted by solve time
     * - Optionally includes current player's rank if not in top results
     *
     * Returns:
     * LeaderboardResponse: Today's leaderboard entries and player rank.
     * @param data The data for the request.
     * @param data.limit
     * @param data.playerId
     * @returns LeaderboardResponse Successful Response
     * @throws ApiError
     */
    public static getTodaysLeaderboard(data: LeaderboardGetTodaysLeaderboardData = {}): CancelablePromise<LeaderboardGetTodaysLeaderboardResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/leaderboard/today',
            query: {
                limit: data.limit,
                player_id: data.playerId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get Leaderboard By Date
     * Get leaderboard for a specific date.
     *
     * For viewing historical rankings.
     *
     * Returns:
     * LeaderboardResponse: Leaderboard entries and player rank.
     *
     * Raises:
     * HTTPException: If puzzle not found for the given date.
     * @param data The data for the request.
     * @param data.leaderboardDate
     * @param data.limit
     * @param data.playerId
     * @returns LeaderboardResponse Successful Response
     * @throws ApiError
     */
    public static getLeaderboardByDate(data: LeaderboardGetLeaderboardByDateData): CancelablePromise<LeaderboardGetLeaderboardByDateResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/leaderboard/{leaderboard_date}',
            path: {
                leaderboard_date: data.leaderboardDate
            },
            query: {
                limit: data.limit,
                player_id: data.playerId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class LoginService {
    /**
     * Login Access Token
     * OAuth2 compatible token login, get an access token for future requests.
     *
     * Args:
     * session: Database session dependency.
     * form_data: OAuth2 password request form with username (email) and password.
     *
     * Returns:
     * Token: Access token response with bearer token.
     *
     * Raises:
     * HTTPException: If credentials are incorrect or user is inactive.
     * @param data The data for the request.
     * @param data.formData
     * @returns Token Successful Response
     * @throws ApiError
     */
    public static loginAccessToken(data: LoginLoginAccessTokenData): CancelablePromise<LoginLoginAccessTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/login/access-token',
            formData: data.formData,
            mediaType: 'application/x-www-form-urlencoded',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Test Token
     * Test access token.
     *
     * Args:
     * current_user: The currently authenticated user.
     *
     * Returns:
     * UserPublic: The current user's public information.
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static testToken(): CancelablePromise<LoginTestTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/login/test-token'
        });
    }
    
    /**
     * Recover Password
     * Password recovery.
     *
     * Args:
     * email: The email address to send recovery link to.
     * session: Database session dependency.
     *
     * Returns:
     * Message: Confirmation message (same response regardless of email existence).
     * @param data The data for the request.
     * @param data.email
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static recoverPassword(data: LoginRecoverPasswordData): CancelablePromise<LoginRecoverPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/password-recovery/{email}',
            path: {
                email: data.email
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Reset Password
     * Reset password.
     *
     * Args:
     * session: Database session dependency.
     * body: New password request with token and new password.
     *
     * Returns:
     * Message: Success message.
     *
     * Raises:
     * HTTPException: If token is invalid or user is inactive.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static resetPassword(data: LoginResetPasswordData): CancelablePromise<LoginResetPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/reset-password/',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Recover Password Html Content
     * HTML content for password recovery.
     *
     * Args:
     * email: The email address to generate recovery content for.
     * session: Database session dependency.
     *
     * Returns:
     * HTMLResponse: HTML content of the password recovery email.
     *
     * Raises:
     * HTTPException: If user with email does not exist.
     * @param data The data for the request.
     * @param data.email
     * @returns string Successful Response
     * @throws ApiError
     */
    public static recoverPasswordHtmlContent(data: LoginRecoverPasswordHtmlContentData): CancelablePromise<LoginRecoverPasswordHtmlContentResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/password-recovery-html-content/{email}',
            path: {
                email: data.email
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class PrivateService {
    /**
     * Create User
     * Create a new user.
     *
     * Args:
     * user_in: User creation data.
     * session: Database session dependency.
     *
     * Returns:
     * UserPublic: The created user's public information.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static createUser(data: PrivateCreateUserData): CancelablePromise<PrivateCreateUserResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/private/users/',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class PuzzleService {
    /**
     * Get Todays Puzzle
     * Get today's puzzle.
     *
     * Creates the puzzle if it doesn't exist yet (lazy generation).
     * Returns tiles only - valid words are never exposed to client.
     *
     * Returns:
     * PuzzleResponse: Today's puzzle with tiles and metadata.
     * @returns PuzzleResponse Successful Response
     * @throws ApiError
     */
    public static getTodaysPuzzle(): CancelablePromise<PuzzleGetTodaysPuzzleResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/puzzle/today'
        });
    }
    
    /**
     * Get Puzzle By Date
     * Get puzzle for a specific date.
     *
     * For practice mode (post-MVP) or viewing past puzzles.
     * Only returns puzzles that already exist (no generation).
     *
     * Returns:
     * PuzzleResponse: The requested puzzle with tiles and metadata.
     *
     * Raises:
     * HTTPException: If puzzle not found for the given date.
     * @param data The data for the request.
     * @param data.puzzleDate
     * @returns PuzzleResponse Successful Response
     * @throws ApiError
     */
    public static getPuzzleByDate(data: PuzzleGetPuzzleByDateData): CancelablePromise<PuzzleGetPuzzleByDateResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/puzzle/{puzzle_date}',
            path: {
                puzzle_date: data.puzzleDate
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class UsersService {
    /**
     * Read Users
     * Retrieve users.
     *
     * Args:
     * session: Database session dependency.
     * skip: Number of users to skip for pagination.
     * limit: Maximum number of users to return.
     *
     * Returns:
     * UsersPublic: List of users with total count.
     * @param data The data for the request.
     * @param data.skip
     * @param data.limit
     * @returns UsersPublic Successful Response
     * @throws ApiError
     */
    public static readUsers(data: UsersReadUsersData = {}): CancelablePromise<UsersReadUsersResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/users/',
            query: {
                skip: data.skip,
                limit: data.limit
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Create User
     * Create new user.
     *
     * Args:
     * session: Database session dependency.
     * user_in: User creation data.
     *
     * Returns:
     * UserPublic: The created user's public information.
     *
     * Raises:
     * HTTPException: If user with email already exists.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static createUser(data: UsersCreateUserData): CancelablePromise<UsersCreateUserResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/users/',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Read User Me
     * Get current user.
     *
     * Args:
     * current_user: The currently authenticated user.
     *
     * Returns:
     * UserPublic: The current user's public information.
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static readUserMe(): CancelablePromise<UsersReadUserMeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/users/me'
        });
    }
    
    /**
     * Delete User Me
     * Delete own user.
     *
     * Args:
     * session: Database session dependency.
     * current_user: The currently authenticated user.
     *
     * Returns:
     * Message: Success message.
     *
     * Raises:
     * HTTPException: If user is a superuser (superusers cannot delete themselves).
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static deleteUserMe(): CancelablePromise<UsersDeleteUserMeResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api/v1/users/me'
        });
    }
    
    /**
     * Update User Me
     * Update own user.
     *
     * Args:
     * session: Database session dependency.
     * user_in: User update data.
     * current_user: The currently authenticated user.
     *
     * Returns:
     * UserPublic: The updated user's public information.
     *
     * Raises:
     * HTTPException: If email already exists for another user.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static updateUserMe(data: UsersUpdateUserMeData): CancelablePromise<UsersUpdateUserMeResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/api/v1/users/me',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Update Password Me
     * Update own password.
     *
     * Args:
     * session: Database session dependency.
     * body: Password update data with current and new password.
     * current_user: The currently authenticated user.
     *
     * Returns:
     * Message: Success message.
     *
     * Raises:
     * HTTPException: If current password is incorrect or new password is same as current.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static updatePasswordMe(data: UsersUpdatePasswordMeData): CancelablePromise<UsersUpdatePasswordMeResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/api/v1/users/me/password',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Register User
     * Create new user without the need to be logged in.
     *
     * Args:
     * session: Database session dependency.
     * user_in: User registration data.
     *
     * Returns:
     * UserPublic: The created user's public information.
     *
     * Raises:
     * HTTPException: If user with email already exists.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static registerUser(data: UsersRegisterUserData): CancelablePromise<UsersRegisterUserResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/users/signup',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Read User By Id
     * Get a specific user by id.
     *
     * Args:
     * user_id: The UUID of the user to retrieve.
     * session: Database session dependency.
     * current_user: The currently authenticated user.
     *
     * Returns:
     * UserPublic: The requested user's public information.
     *
     * Raises:
     * HTTPException: If user not found or current user lacks privileges.
     * @param data The data for the request.
     * @param data.userId
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static readUserById(data: UsersReadUserByIdData): CancelablePromise<UsersReadUserByIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/users/{user_id}',
            path: {
                user_id: data.userId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Update User
     * Update a user.
     *
     * Args:
     * session: Database session dependency.
     * user_id: The UUID of the user to update.
     * user_in: User update data.
     *
     * Returns:
     * UserPublic: The updated user's public information.
     *
     * Raises:
     * HTTPException: If user not found or email already exists for another user.
     * @param data The data for the request.
     * @param data.userId
     * @param data.requestBody
     * @returns UserPublic Successful Response
     * @throws ApiError
     */
    public static updateUser(data: UsersUpdateUserData): CancelablePromise<UsersUpdateUserResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/api/v1/users/{user_id}',
            path: {
                user_id: data.userId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Delete User
     * Delete a user.
     *
     * Args:
     * session: Database session dependency.
     * current_user: The currently authenticated superuser.
     * user_id: The UUID of the user to delete.
     *
     * Returns:
     * Message: Success message.
     *
     * Raises:
     * HTTPException: If user not found or trying to delete themselves.
     * @param data The data for the request.
     * @param data.userId
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static deleteUser(data: UsersDeleteUserData): CancelablePromise<UsersDeleteUserResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api/v1/users/{user_id}',
            path: {
                user_id: data.userId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
}

export class UtilsService {
    /**
     * Test Email
     * Test emails.
     *
     * Args:
     * email_to: The email address to send the test email to.
     *
     * Returns:
     * Message: Success message.
     * @param data The data for the request.
     * @param data.emailTo
     * @returns Message Successful Response
     * @throws ApiError
     */
    public static testEmail(data: UtilsTestEmailData): CancelablePromise<UtilsTestEmailResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/utils/test-email/',
            query: {
                email_to: data.emailTo
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Health Check
     * Health check endpoint.
     *
     * Returns:
     * bool: Always returns True to indicate the service is healthy.
     * @returns boolean Successful Response
     * @throws ApiError
     */
    public static healthCheck(): CancelablePromise<UtilsHealthCheckResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/utils/health-check/'
        });
    }
}